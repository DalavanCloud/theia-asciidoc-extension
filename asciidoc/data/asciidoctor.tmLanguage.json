{
    "fileTypes": [
        "adoc",
        "ad",
        "asciidoc"
    ],
    "name": "AsciiDoc (Asciidoctor)",
    "patterns": [
        {
            "include": "#lists"
        },
        {
            "include": "#blocks"
        },
        {
            "include": "#section_titles"
        },
        {
            "include": "#lines"
        },
        {
            "include": "#inline"
        },
        {
            "include": "#characters"
        }
    ],
    "repository": {
        "attribute_entry": {
            "begin": "(?x)\n^(:)                          # opening delimiter\n(!)?                          # bang symbol (unset attribute)\n([A-Za-z0-9_][A-Za-z0-9_-]*)  # attribute name\n(!)?                          # bang symbol (unset attribute)\n(:)                           # closing delimiter\n(?:\\s+|(?=$))",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.definition.attributeentry.attrname.begin.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.attributeentry.unset.asciidoc"
                },
                "3": {
                    "name": "support.variable.attribute.asciidoc"
                },
                "4": {
                    "name": "punctuation.definition.attributeentry.unset.asciidoc"
                },
                "5": {
                    "name": "punctuation.definition.attributeentry.attrname.end.asciidoc"
                }
            },
            "comment": "An attribute entry.\n\nExamples:\n  :my-attribute: value\n  :sectnums!:\n  :!sectnums:\n",
            "contentName": "meta.attributeentry.value.asciidoc",
            "end": "$\\n?",
            "name": "meta.attributeentry.asciidoc",
            "patterns": [
                {
                    "include": "#characters"
                }
            ]
        },
        "attribute_list_line": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.attributelistline.begin.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.attributelistline.end.asciidoc"
                }
            },
            "comment": "Attribute list as paragraph: single brackets. No need for special treatment of escape; follows literal block, section template as being a more general regex.\n",
            "match": "^(\\[)[^\\[\\]]*(\\])\\s*$\\n?",
            "name": "support.variable.attributelist.asciidoc"
        },
        "attribute_reference": {
            "captures": {
                "1": {
                    "name": "constant.character.attributes.reference.begin.asciidoc"
                },
                "2": {
                    "name": "support.variable.attribute.asciidoc"
                },
                "3": {
                    "name": "constant.character.attributes.reference.end.asciidoc"
                }
            },
            "comment": "Examples:\n  {my-attribute}\n",
            "match": "({)([A-Za-z0-9_][A-Za-z0-9_-]*)(})",
            "name": "variable.other"
        },
        "biblio_anchor": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.biblioanchor.begin.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.biblioanchor.end.asciidoc"
                }
            },
            "comment": "Bibliography anchor\n\nExamples:\n  [[[Lorem ipsum]]]\n",
            "match": "(?<!\\[)(\\[\\[\\[).*?(\\]\\]\\])(?!\\])",
            "name": "storage.type.reference.biblioanchor.asciidoc"
        },
        "block_admonition_label": {
            "comment": "Label of an admonition block.\n\nExamples:\n  NOTE: This is a admonition block.\n  WARNING:  Be aware of them!\n",
            "match": "^(NOTE|TIP|IMPORTANT|WARNING|CAUTION):(?=\\s+)",
            "name": "support.constant.admonitionword.asciidoc"
        },
        "block_comment": {
            "begin": "^(\/{4,})\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "punctuation.definition.comment.begin.asciidoc"
                }
            ],
            "comment": "Examples:\n  \/\/\/\/\n  A multi-line comment.\n  Notice it's a delimited block.\n  \/\/\/\/\n",
            "contentName": "meta.block.comment.content.asciidoc",
            "end": "^\\1\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "punctuation.definition.comment.end.asciidoc"
                }
            ],
            "name": "comment.block.asciidoc",
            "patterns": [
                {
                    "include": "#macro"
                }
            ]
        },
        "block_example": {
            "begin": "^(={4,})\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "constant.delimiter.example.begin.asciidoc"
                }
            ],
            "comment": "Examples:\n  ====\n  Lorem ipsum.\n  ====\n\nNote: Might need to add more includes, but these are the ones that arise in\npractice for me.\n",
            "contentName": "meta.block.example.content.asciidoc",
            "end": "^\\1\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "constant.delimiter.example.end.asciidoc"
                }
            ],
            "name": "string.unquoted.block.example.asciidoc",
            "patterns": [
                {
                    "include": "#lists"
                },
                {
                    "include": "#block_listing"
                },
                {
                    "include": "#lines"
                },
                {
                    "include": "#inline"
                },
                {
                    "include": "#characters"
                }
            ]
        },
        "block_id": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.blockid.begin.asciidoc"
                },
                "2": {
                    "name": "markup.underline.blockid.id.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.blockid.end.asciidoc"
                }
            },
            "comment": "A block id (i.e. anchor).\n\nExamples:\n  [[myid]]\n  Lorem ipsum dolor.\n",
            "match": "^(\\[\\[)([^\\[].*)(\\]\\])\\s*$\\n?",
            "name": "meta.tag.blockid.asciidoc"
        },
        "block_listing": {
            "begin": "^(\\-{4,})\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "markup.underline.listing.begin.asciidoc"
                }
            ],
            "comment": "Examples:\n  ----\n  Lorem ipsum.\n  ----\n",
            "contentName": "source.block.listing.content.asciidoc",
            "end": "^\\1\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "markup.underline.listing.end.asciidoc"
                }
            ],
            "name": "meta.embedded.block.listing.asciidoc",
            "patterns": [
                {
                    "include": "#inline_callout"
                }
            ]
        },
        "block_literal": {
            "begin": "^(\\.{4,})\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "constant.delimiter.block.literal.begin.asciidoc"
                }
            ],
            "comment": "Examples:\n  ....\n  Lorem ipsum.\n  ....\n",
            "contentName": "meta.block.literal.content.asciidoc",
            "end": "^\\1\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "constant.delimiter.block.literal.end.asciidoc"
                }
            ],
            "name": "string.literal.block.delimited.asciidoc",
            "patterns": [
                {
                    "include": "#inline_callout"
                }
            ]
        },
        "block_open": {
            "begin": "^\\-\\-\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "markup.underline.block.open.begin.asciidoc"
                }
            ],
            "comment": "Examples:\n  --\n  Lorem ipsum\n  --\nNote: Might need to check on these includes.\n",
            "contentName": "meta.block.open.content.asciidoc",
            "end": "^\\-\\-\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "markup.underline.block.open.begin.asciidoc"
                }
            ],
            "name": "meta.block.open.asciidoc",
            "patterns": [
                {
                    "include": "#lists"
                },
                {
                    "include": "#block_comment"
                },
                {
                    "include": "#block_listing"
                },
                {
                    "include": "#block_pass"
                },
                {
                    "include": "#lines"
                },
                {
                    "include": "#inline"
                },
                {
                    "include": "#characters"
                }
            ]
        },
        "block_page_break": {
            "comment": "A page break.\n\nExamples:\n  <<<\n  <<<<<\n",
            "match": "^<{3,}$\\n?",
            "name": "meta.separator.pagebreak.asciidoc"
        },
        "block_pass": {
            "begin": "^(\\+{4,})\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "markup.underline.block.passthrough.begin.asciidoc"
                }
            ],
            "contentName": "text.xml.block.passthrough.content.asciidoc",
            "end": "^\\1\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "markup.underline.block.passthrough.end.asciidoc"
                }
            ],
            "name": "meta.embedded.block.passthrough.asciidoc",
            "patterns": [
                {
                    "include": "text.xml"
                }
            ]
        },
        "block_quote": {
            "begin": "^(_{4,})\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "constant.delimiter.block.quote.begin.asciidoc"
                }
            ],
            "comment": "Examples:\n  ____\n  Lorem ipsum\n  ____\n\nNote: Might need to add more includes, but these are the ones that arise for me in practice.\n",
            "contentName": "meta.block.quote.content.asciidoc",
            "end": "^\\1\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "constant.delimiter.block.quote.end.asciidoc"
                }
            ],
            "name": "markup.quote.block.asciidoc",
            "patterns": [
                {
                    "include": "#lines"
                },
                {
                    "include": "#inline"
                },
                {
                    "include": "#characters"
                }
            ]
        },
        "block_req": {
            "captures": {
                "1": {
                    "name": "markup.underline.block.id.asciidoc"
                },
                "3": {
                    "name": "variable.parameter.reqid.id.asciidoc"
                },
                "4": {
                    "name": "markup.underline.block.version.asciidoc"
                },
                "6": {
                    "name": "variable.parameter.reqversion.id.asciidoc"
                },
                "7": {
                    "name": "markup.underline.block.id.asciidoc"
                }
            },
            "comment": "A requirement id (i.e. anchor).\nExamples:\n  [req,id=ROPR1234,version=1]\n  Lorem ipsum dolor.\n",
            "match": "(\\[req,(\\s+)?id=)(.+?)(,(\\s+)?version=)([0-9])(\\])",
            "name": "meta.tag.blockid.req.asciidoc"
        },
        "block_sidebar": {
            "begin": "^(\\*{4,})\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "constant.delimiter.block.sidebar.begin.asciidoc"
                }
            ],
            "comment": "Examples:\n  ****\n  Lorem ipsum\n  ****\n\nNote: Might need to add more includes, but these are the ones that arise\nfor me in practice.\n",
            "contentName": "meta.block.sidebar.content.asciidoc",
            "end": "^\\1\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "constant.delimiter.block.sidebar.end.asciidoc"
                }
            ],
            "name": "string.quoted.block.sidebar.asciidoc",
            "patterns": [
                {
                    "include": "#lists"
                },
                {
                    "include": "#block_comment"
                },
                {
                    "include": "#block_listing"
                },
                {
                    "include": "#lines"
                },
                {
                    "include": "#inline"
                },
                {
                    "include": "#characters"
                }
            ]
        },
        "block_source_fenced": {
            "begin": "^(```)(\\w+)?\\s*$\\n?",
            "beginCaptures": [
                {
                    "name": "constant.delimiter.listing.begin.asciidoc"
                }
            ],
            "comment": "Fenced code block (ala Markdown)\n\nExamples:\n  ```rb\n  puts 'Hello world!'\n  ```\n",
            "contentName": "source.block.listing.content.asciidoc",
            "end": "^\\1\\s*$\\n?",
            "endCaptures": [
                {
                    "name": "constant.delimiter.listing.end.asciidoc"
                }
            ],
            "name": "meta.embedded.block.listing.asciidoc",
            "patterns": [
                {
                    "include": "#inline_callout"
                }
            ]
        },
        "block_thematic_break": {
            "comment": "A thematic break (aka horizontal rule).\n\nExamples:\n  '''\n  ''''''\n",
            "match": "^'{3,}$\\n?",
            "name": "meta.separator.ruler.asciidoc"
        },
        "block_title": {
            "comment": "Title of a block. Exludes custom block titles for better\nscoping \/ preventing overlap.\n\nExamples:\n  .My title\n  Lorem ipsum dolor.\n",
            "match": "^(\\.)\\w.*$\\n?",
            "name": "markup.heading.block.asciidoc"
        },
        "blocks": {
            "patterns": [
                {
                    "include": "#block_literal"
                },
                {
                    "include": "#block_comment"
                },
                {
                    "include": "#custom_block"
                },
                {
                    "include": "#block_listing"
                },
                {
                    "include": "#block_source_fenced"
                },
                {
                    "include": "#block_sidebar"
                },
                {
                    "include": "#block_pass"
                },
                {
                    "include": "#block_quote"
                },
                {
                    "include": "#block_example"
                },
                {
                    "include": "#block_open"
                }
            ]
        },
        "characters": {
            "patterns": [
                {
                    "include": "#attribute_reference"
                },
                {
                    "include": "#entity_number"
                },
                {
                    "include": "#entity_name"
                },
                {
                    "include": "#escape"
                },
                {
                    "include": "#replacement"
                },
                {
                    "include": "#macro_pass"
                },
                {
                    "include": "#macro"
                },
                {
                    "include": "#xref"
                },
                {
                    "include": "#biblio_anchor"
                },
                {
                    "include": "#indexterm_triple"
                },
                {
                    "include": "#indexterm_double"
                }
            ]
        },
        "colist_item_marker": {
            "captures": {
                "1": {
                    "name": "string.unquoted.list.callout.asciidoc"
                },
                "2": {
                    "name": "constant.numeric.callout.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.calloutlistnumber.begin.asciidoc"
                },
                "4": {
                    "name": "punctuation.definition.calloutlistnumber.end.asciidoc"
                }
            },
            "comment": "Marker of a callout list item.\n\nExamples:\n  <1> a callout\n  <42> another callout\n",
            "match": "^(\\s*((<)\\d+?(>)))\\s+(?=\\S)",
            "name": "markup.list.numbered.callout.asciidoc"
        },
        "custom_block": {
            "captures": {
                "1": {
                    "name": "markup.underline.block.asciidoc"
                },
                "2": {
                    "name": "markup.underline.block.asciidoc"
                },
                "3": {
                    "name": "variable.parameter.sourcelang.asciidoc"
                },
                "4": {
                    "name": "markup.underline.block.asciidoc"
                }
            },
            "match": "(?x)^\n(\\[)\n(sect\\d|def|math|TODO|quote|example|source,?(\\w+))\n(\\s*\\])\n\\s*$\\n?\n",
            "name": "markup.underline.block.id.def.asciidoc"
        },
        "dlist_item_label": {
            "begin": "^\\s*(?=.*:{2,4}(?:\\s|$))",
            "comment": "Label of a definition (labeled) list item.\n\nExamples:\n  Label level 1:: lorem ipsum\n  Label level 2::: dolor sit amet\n  Label level 3:::: consectetur\n  Label level 1::\n    lorem ipsum\n  Another label :: lorem ipsum\n  Last::label:: dolor sit amet\n\nNote: This rule is not strictly correct, because Asciidoctor allows\ndouble colon followed by a space inside a label, i.e. it matches the\n*last* double colon, not the first. I don't know how to do that\n*effectively.\n",
            "contentName": "meta.list.label.asciidoc",
            "end": "(:{2,4})(?:\\s|$\\n?)",
            "endCaptures": {
                "1": {
                    "name": "constant.labeledlist.separator.asciidoc"
                }
            },
            "name": "markup.list.labeled.asciidoc",
            "patterns": [
                {
                    "include": "#inline"
                },
                {
                    "include": "#characters"
                }
            ]
        },
        "emphasis": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.italic.single.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.italic.single.end.asciidoc"
                }
            },
            "comment": "Emphasized (italic) text (constrained variant).\n\nExamples:\n  _Lorem ipsum_ dolor\n  [red]_Lorem ipsum_ dolor\n",
            "match": "(?!_{4,}\\s*$)(?<=^|[^\\p{Word};:])(\\[(?:[^\\]]+?)\\])?((_)(\\S|\\S.*?\\S)(_))(?!\\p{Word})",
            "name": "markup.italic.single.asciidoc"
        },
        "emphasis_double": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.italic.double.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.italic.double.end.asciidoc"
                }
            },
            "comment": "Emphasized (italic) text (unconstrained variant).\n\nExamples:\n  Lo__re__m __ipsum dolor__.\n  Lo[red]__re__m\n",
            "match": "(?<!\\\\\\\\)(\\[(?:[^\\]]+?)\\])?((__)((?!_).+?)(__))",
            "name": "markup.italic.double.asciidoc"
        },
        "entity_name": {
            "comment": "Character entity reference\n\nExamples:\n  &nbsp;\n  &sup2;\n",
            "match": "(?<!\\\\)&([a-zA-Z][a-zA-Z0-9]*);",
            "name": "constant.character.entity.xml.asciidoc"
        },
        "entity_number": {
            "comment": "Numeric character reference\n\nExamples:\n  &#x278a;\n  &#182;\n",
            "match": "(?<!\\\\)&#(x?[0-9a-fA-f]{2,4});",
            "name": "constant.character.entity.asciidoc"
        },
        "escape": {
            "comment": "List of special characters that may be escaped.\n\nNote: I do not really know if this is a good list, adopted wholesale from\noriginal bundle.\n",
            "match": "\\\\(?=[-`*_#+.!(){}\\[\\]\\\\>:])",
            "name": "constant.character.escape.asciidoc"
        },
        "indexterm_double": {
            "captures": {
                "1": {
                    "name": "constant.character.indexterm.double.begin.asciidoc"
                },
                "3": {
                    "name": "constant.character.indexterm.double.end.asciidoc"
                }
            },
            "comment": "Double parenthesis indexterm.\n\nExamples:\n  ((Arthur))\n",
            "match": "(?<!\\()(\\({2})([^\\(\\s].*?)(\\){2})(?!\\))",
            "name": "variable.other.indexterm.double.asciidoc"
        },
        "indexterm_triple": {
            "captures": {
                "1": {
                    "name": "constant.character.indexterm.triple.begin.asciidoc"
                },
                "3": {
                    "name": "constant.character.indexterm.triple.end.asciidoc"
                }
            },
            "comment": "Triple parenthesis indexterm.\n\nExamples:\n  (((Sword, Broadsword, Excalibur)))\n",
            "match": "(?<!\\()(\\({3})([^\\(].*?)(\\){3})(?!\\))",
            "name": "variable.other.indexterm.triple.asciidoc"
        },
        "inline": {
            "patterns": [
                {
                    "include": "#passthrough"
                },
                {
                    "include": "#strong_double"
                },
                {
                    "include": "#emphasis_double"
                },
                {
                    "include": "#monospaced_double"
                },
                {
                    "include": "#mark_double"
                },
                {
                    "include": "#strong"
                },
                {
                    "include": "#emphasis"
                },
                {
                    "include": "#monospaced"
                },
                {
                    "include": "#mark"
                },
                {
                    "include": "#superscript"
                },
                {
                    "include": "#subscript"
                }
            ]
        },
        "inline_break": {
            "comment": "Line hard break with a plus sign (+).\n\nExamples:\n  Rubies are red, +\n  Topazes are blue.\n",
            "match": "(?<=\\s)\\+$\\n?",
            "name": "constant.linebreak.asciidoc"
        },
        "inline_callout": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.callout.begin.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.callout.end.asciidoc"
                }
            },
            "comment": "Callout label\n\nExamples:\n  <1>\n  <42>\n",
            "match": "(?<!\\\\)(<)\\d+(>)",
            "name": "constant.other.callout.asciidoc"
        },
        "inline_comment": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.comment.line.asciidoc"
                },
                "2": {
                    "name": "meta.line.comment.content.asciidoc"
                }
            },
            "comment": "Inline comment.\n\nExamples:\n  \/\/ This is just a comment!\n",
            "match": "^(\/\/)([^\/\\n].*|)$\\n?",
            "name": "comment.line.double-slash.asciidoc"
        },
        "lines": {
            "patterns": [
                {
                    "include": "#inline_comment"
                },
                {
                    "include": "#list_continuation"
                },
                {
                    "include": "#inline_break"
                },
                {
                    "include": "#block_page_break"
                },
                {
                    "include": "#block_thematic_break"
                },
                {
                    "include": "#block_title"
                },
                {
                    "include": "#block_id"
                },
                {
                    "include": "#block_req"
                },
                {
                    "include": "#section_template"
                },
                {
                    "include": "#attribute_list_line"
                },
                {
                    "include": "#attribute_entry"
                }
            ]
        },
        "list_continuation": {
            "match": "^\\+\\s*$\\n?",
            "name": "constant.listcontinuation.asciidoc"
        },
        "lists": {
            "comment": "My strategy for lists (and similar) is not to try to treat entire paragraphs as lists, but only call out the opening.\n",
            "patterns": [
                {
                    "include": "#block_admonition_label"
                },
                {
                    "include": "#ulist_item_marker"
                },
                {
                    "include": "#olist_item_marker"
                },
                {
                    "include": "#dlist_item_label"
                },
                {
                    "include": "#colist_item_marker"
                }
            ]
        },
        "macro": {
            "captures": {
                "1": {
                    "name": "markup.underline.link.macro.asciidoc"
                },
                "3": {
                    "name": "keyword.control.name.macro.asciidoc"
                },
                "4": {
                    "name": "constant.character.separator.macro.asciidoc"
                },
                "5": {
                    "name": "markup.underline.target.macro.asciidoc"
                },
                "6": {
                    "name": "constant.character.attributes.macro.begin.asciidoc"
                },
                "7": {
                    "name": "variable.parameter.attributes.macro.asciidoc"
                },
                "8": {
                    "name": "constant.character.attributes.macro.end.asciidoc"
                }
            },
            "comment": "Note: There are other macro notations, but I match only those that end in\nsquare brackets.\n",
            "match": "(?x)\n(?:\n  ((?:https?|mailto|ftp|file)  # specify separately so we can mark them as links that TextMate opens\n  ?:{1}  # inline only\n  \\S*)   # (others such as image are partial URLs and\/or TextMate cannot handle them)\n|\n  (([a-zA-Z0-9][a-zA-Z0-9_]*)\n  (:{1,2})\n  (\\S*))\n)\n(?:(\\[)([^\\]]*)(\\]))",
            "name": "meta.macro.asciidoc"
        },
        "macro_pass": {
            "begin": "(?x)\n(pass)\n(:{1,2})\n(\\S*)\n(\\[)(?=[^\\]]*\\])",
            "captures": {
                "1": {
                    "name": "keyword.control.name.macro.pass.asciidoc"
                },
                "2": {
                    "name": "constant.character.separator.macro.asciidoc"
                },
                "3": {
                    "name": "markup.underline.target.macro.asciidoc"
                },
                "4": {
                    "name": "constant.character.attributes.macro.begin.asciidoc"
                }
            },
            "comment": "Passthrough macro\n\nExamples:\n  pass:[Lorem ipsum]\n  pass::[Lorem ipsum]\n",
            "contentName": "variable.parameter.attributes.macro.pass.asciidoc",
            "end": "\\]",
            "endCaptures": [
                {
                    "name": "constant.character.attributes.macro.end.asciidoc"
                }
            ],
            "name": "meta.macro.pass.asciidoc",
            "patterns": [
                {
                    "include": "text.xml"
                }
            ]
        },
        "mark": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.string.unquoted.single.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.string.unquoted.single.end.asciidoc"
                }
            },
            "comment": "Marked text (constrained variant).\n\nExamples:\n  #Lorem ipsum# dolor\n  [red]#Lorem ipsum# dolor\n",
            "match": "((?<![\\\\;:\\p{Word}#])(\\[[^\\]]+?\\])((#)(\\S|\\S.*?\\S)(#)(?!\\p{Word})))|((?<![\\\\;:\\p{Word}#])(\\[[^\\]]+?\\])?((#)(\\S|\\S.*?\\S)(#)(?!\\p{Word})))",
            "name": "string.other.unquoted.single.asciidoc"
        },
        "mark_double": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.string.unquoted.double.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.string.unquoted.double.end.asciidoc"
                }
            },
            "comment": "Marked text (unconstrained variant).\n\nExamples:\n  Lo##re##m ##ipsum dolor##.\n  Lo[red]##re##m\n",
            "match": "((?<!\\\\\\\\)(\\[[^\\]]+?\\])((##)(.+?)(##)))|((?<!\\\\\\\\)((##)(.+?)(##)))",
            "name": "string.other.unquoted.double.asciidoc"
        },
        "monospaced": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.literal.single.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.literal.single.end.asciidoc"
                }
            },
            "comment": "Monospaced text (constrained variant).\n\nExamples:\n  `Lorem ipsum` dolor\n  [red]`Lorem ipsum` dolor\n",
            "match": "(?<![\\\\;:\\p{Word}\\\"'`])(\\[.+?\\])?((`)(\\S|\\S.*?\\S)(`))(?![\\p{Word}\\\"'`])",
            "name": "string.other.literal.single.asciidoc"
        },
        "monospaced_double": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.literal.double.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.literal.double.end.asciidoc"
                }
            },
            "comment": "Monospaced text (unconstrained variant).\n\nExamples:\n  Lo``re``m ``ipsum dolor``.\n  Lo[red]``re``m\n",
            "match": "(?<!\\\\)(\\[.+?\\])?((``)(.+?)(``))",
            "name": "string.other.literal.double.asciidoc"
        },
        "olist_item_marker": {
            "captures": {
                "1": {
                    "name": "string.unquoted.list.dotted.asciidoc"
                },
                "2": {
                    "name": "constant.numeric.list.dot.asciidoc"
                }
            },
            "comment": "Marker of an ordered (numbered) list item.\n\nExamples:\n  . level 1\n  .. level 2\n  ... level 3\n  .... level 4\n  ..... level 5\n\nNote: The space distinguishes it from a block title.\n",
            "match": "^(\\s*(\\.{1,5}))\\s+(?=\\S)",
            "name": "markup.list.numbered.dotted.asciidoc"
        },
        "passthrough": {
            "begin": "(\\+\\+\\+|\\$\\$)",
            "beginCaptures": {
                "1": {
                    "name": "constant.character.passthru.begin.asciidoc"
                }
            },
            "comment": "Inline triple-plus and double dolar passthrough.\n\nExamples:\n  Lo+++re++++m +++ipsum dolor+++.\n  Lo$$re$$m $$ipsum dolor$$.\n\nNote: Must be dead first among the inlines, so as to take priority.\n",
            "contentName": "variable.parameter.passthruinner.asciidoc",
            "end": "\\1",
            "endCaptures": [
                {
                    "name": "constant.character.passthru.end.asciidoc"
                }
            ],
            "name": "meta.passthru.inline.asciidoc"
        },
        "replacement": {
            "match": "(?x)\n(?<!\\\\)  # must not be escaped\n(\n  \\(C\\)\n  | \\(TM\\)\n  | \\(R\\)\n  | ((?<!\\-)\\-\\-(?!\\-))    # exactly two, and even this may not rule out all that I want to\n  | ((?<!\\.)\\.\\.\\.(?!\\.))  # exactly three\n  | \\->\n  | <\\-\n  | =>\n  | <=\n)",
            "name": "constant.character.replacement.asciidoc"
        },
        "section_template": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.sectiontemplate.begin.asciidoc"
                },
                "4": {
                    "name": "meta.tag.sectiontemplate.asciidoc"
                },
                "6": {
                    "name": "punctuation.definition.sectiontemplate.end.asciidoc"
                },
                "7": {
                    "name": "punctuation.definition.sectiontemplate.end.asciidoc"
                }
            },
            "comment": "fixed list of known template names",
            "match": "(?x)^\n(\\[)  # in square brackets\n(template\\s*=\\s*)?(\")?  # might start with template-equals and might have template name in quotes\n(\nsect\\d|abstract|preface|colophon|dedication|glossary|bibliography|synopsis|appendix|index # fixed list of known templates\n)\n(\".*(\\])|(\\]))  # either close the quote (and perhaps go on) and close the bracket, or close the bracket immediately\n\\s*$\\n?\n",
            "name": "variable.parameter.sectiontemplate.asciidoc"
        },
        "section_titles": {
            "comment": "Examples:\n\n  = Document Title (Level 0)\n\n  == Level 1 Section\n\n  === Level 2 Section\n",
            "patterns": [
                {
                    "include": "#title_level_5"
                },
                {
                    "include": "#title_level_4"
                },
                {
                    "include": "#title_level_3"
                },
                {
                    "include": "#title_level_2"
                },
                {
                    "include": "#title_level_1"
                },
                {
                    "include": "#title_level_0"
                }
            ]
        },
        "strong": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.bold.single.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.bold.single.end.asciidoc"
                }
            },
            "comment": "Strong (bold) text (constrained variant).\n\nExamples:\n  *Lorem ipsum* dolor\n  [red]*Lorem ipsum* dolor\n",
            "match": "(?<![\\\\;:\\p{Word}\\*])(\\[.+?\\])?((\\*)(\\S|\\S.*?\\S)(\\*)(?!\\p{Word}))",
            "name": "markup.bold.single.asciidoc"
        },
        "strong_double": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.bold.double.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.bold.double.end.asciidoc"
                }
            },
            "comment": "Strong (bold) text (unconstrained variant).\n\nExamples:\n  Lo**re**m **ipsum dolor**.\n  Lo[red]**re**m\n",
            "match": "(?<!\\\\\\\\)(\\[.+?\\])?((\\*\\*)(.+?)(\\*\\*))",
            "name": "markup.bold.double.asciidoc"
        },
        "subscript": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.string.subscript.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.string.subscript.end.asciidoc"
                }
            },
            "comment": "Subscript text.\n\nExamples:\n  H~2~O\n  H[red]~2~O\n",
            "match": "(?<!\\\\)(\\[.+?\\])?((~)(\\S+?)(~))",
            "name": "string.other.subscript.asciidoc"
        },
        "superscript": {
            "captures": {
                "1": {
                    "name": "support.variable.attributelist.asciidoc"
                },
                "2": {
                    "name": "punctuation.definition.string.superscript.begin.asciidoc"
                },
                "3": {
                    "name": "punctuation.definition.string.superscript.end.asciidoc"
                }
            },
            "comment": "Superscript text.\n\nExamples:\n  E=mc^2^\n  E=mc[red]^2^\n",
            "match": "(?<!\\\\)(\\[.+?\\])?((\\^)(\\S+?)(\\^))",
            "name": "string.other.superscript.asciidoc"
        },
        "title_level_0": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.heading.asciidoc"
                },
                "2": {
                    "name": "entity.name.section.asciidoc"
                }
            },
            "match": "^(=) (\\S.*)$\\n?",
            "name": "markup.heading.level.0.asciidoc"
        },
        "title_level_1": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.heading.asciidoc"
                },
                "2": {
                    "name": "entity.name.section.asciidoc"
                }
            },
            "match": "^(==) (\\S.*)$\\n?",
            "name": "markup.heading.level.1.asciidoc"
        },
        "title_level_2": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.heading.asciidoc"
                },
                "2": {
                    "name": "entity.name.section.asciidoc"
                }
            },
            "match": "^(===) (\\S.*)$\\n?",
            "name": "markup.heading.level.2.asciidoc"
        },
        "title_level_3": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.heading.asciidoc"
                },
                "2": {
                    "name": "entity.name.section.asciidoc"
                }
            },
            "match": "^(====) (\\S.*)$\\n?",
            "name": "markup.heading.level.3.asciidoc"
        },
        "title_level_4": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.heading.asciidoc"
                },
                "2": {
                    "name": "entity.name.section.asciidoc"
                }
            },
            "match": "^(=====) (\\S.*)$\\n?",
            "name": "markup.heading.level.4.asciidoc"
        },
        "title_level_5": {
            "captures": {
                "1": {
                    "name": "punctuation.definition.heading.asciidoc"
                },
                "2": {
                    "name": "entity.name.section.asciidoc"
                }
            },
            "match": "^(======) (\\S.*)$\\n?",
            "name": "markup.heading.level.5.asciidoc"
        },
        "ulist_item_marker": {
            "captures": {
                "1": {
                    "name": "string.unquoted.list.bullet.asciidoc"
                },
                "2": {
                    "name": "constant.numeric.list.bullet.asciidoc"
                }
            },
            "comment": "Marker of an unordered (bullet) list item.\n\nExamples:\n  * level 1\n  ** level 2\n  *** level 3\n  **** level 4\n  ***** level 5\n  - level 1\n  -- level 2\n  --- level 3\n  ---- level 4\n  ----- level 5\n",
            "match": "^(\\s*(\\-|\\*{1,5}))\\s+(?=\\S)",
            "name": "markup.list.bulleted.asciidoc"
        },
        "xref": {
            "captures": {
                "1": {
                    "name": "constant.character.xref.begin.asciidoc"
                },
                "2": {
                    "name": "markup.underline.term.xref.asciidoc"
                },
                "5": {
                    "name": "variable.parameter.xref.asciidoc"
                },
                "6": {
                    "name": "constant.character.xref.end.asciidoc"
                }
            },
            "comment": "Internal cross-reference\n\nExamples:\n  <<lorem>>\n  <<lorem, see here>>\n",
            "match": "(?<!<)(<<)([^,]*?)((,\\s*)(.*?))?(>>)(?!<)",
            "name": "meta.xref.asciidoc"
        }
    },
    "scopeName": "text.asciidoc",
    "uuid": "A2AE6D21-3F08-4978-ADF3-55B5AD580921"
}